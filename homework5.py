# Anatoli Gutovski
# Homework-5
# 31-03-2024
# Grodno-IT-Academy-Python 3.11.7


# Реализовать функцию get_ranges которая получает на вход непустой список неповторяющихся целых чисел,
# отсортированных по возрастанию, которая этот список “сворачивает”.
# get_ranges([0, 1, 2, 3, 4, 7, 8, 10])  #  "0-4, 7-8, 10"
# get_ranges([4,7,10])  # "4, 7, 10"
# get_ranges([2, 3, 8, 9])  # "2-3, 8-9"
import math
import re


def get_ranges(lst):
    # Создадим пустой список ranges, в который будут добавляться диапазоны или отдельные числа
    ranges = []
    # Инициализируем переменные start и end значением первого элемента списка lst
    start = end = lst[0]

    # Создадим цикл по индексам элементов списка lst, начиная с индекса 1
    for i in range(1, len(lst)):
        # Проверим, является ли текущий элемент следующим числом после end
        if lst[i] == end + 1:
            end = lst[i]
        else:
            # Проверим, являются ли start и end одинаковыми
            if start == end:
                # Если start и end одинаковы, добавляем строковое представление start в список ranges
                ranges.append(str(start))
            else:
                # Иначе обновим строку вида "start-end" в список ranges
                ranges.append(f"{start}-{end}")
            # Обновим переменные start и end значением текущего элемента списка
            start = end = lst[i]
    # Проверим, являются ли start и end одинаковыми после завершения цикла
    if start == end:
        # Если start и end одинаковы, добавим строковое представление start в список ranges
        ranges.append(str(start))
    else:
        # Иначе добавляем строку вида "start-end" в список ranges
        ranges.append(f"{start}-{end}")

    # Объединим все элементы списка ranges в одну строку, разделенную запятыми и пробелами, и возвращаем эту строку
    return ", ".join(ranges)
    # Решение ок, замечаний нет.


# Написать функцию standardise_phones которая принимает любое
# количество нестандартизированных телефонных номеров и возвращает
# список стандартизированных номеров в том порядке в котором они были
# введены. А если число не является номером - возвращает пустой список
# standardise_phones("298884455") # ["+375298884455"]
# standardise_phones("(29)888-44-55","8029 8885555","+375299998877","375299998867") # ["+375298884455","+375298885555","+375299998877","+375299998867"]
# standardise_phones("298884asd45") # []


def standardise_phones(*args):
    # Здесь мы определяем внутреннюю функцию с именем standardise_phone, которая принимает один аргумент phone
    def standardise_phone(phone):
        # Внутри standardise_phone мы удаляем все нецифровые символы из phone с помощью регулярного выражения
        phone = re.sub(r'\D', '', phone)
        # Если длина phone равна 11 и номер начинается с ‘8’, выполняется следующая строка кода
        if len(phone) == 11 and phone.startswith('8'):
            # Мы добавляем код страны (Беларусь) к номеру, обрезая первые два символа
            phone = '+375' + phone[2:]
        # Если длина phone равна 9, выполняется следующая строка кода
        elif len(phone) == 9:
            # Мы добавляем код страны (Беларусь) к номеру
            phone = '+375' + phone
        # Если длина phone равна 13, номер остается без изменений
        elif len(phone) == 13:
            phone = phone
        # Если длина phone равна 12 и номер начинается с ‘3’, выполняется следующая строка кода
        elif len(phone) == 12 and phone.startswith('3'):
            # Мы добавляем символ ‘+’ перед номером
            phone = '+' + phone[0:]
        else:
            # Если ни одно из условий не выполнилось, возвращается None
            return None
        # Возвращается стандартизированный phone
        return phone

    # Создается список standardized_phones, в который добавляются результаты вызова standardise_phone для каждого аргумента.
    standardized_phones = [standardise_phone(str(phone)) for phone in args]
    # Возвращается список стандартизированных номеров, исключая None
    return [phone for phone in standardized_phones if phone]
    # Решение рабочее, тесты оно успешно проходит, есть более универсальное, см ответы

# Создайте декоратор handle_multiples который позволит функции rope_product
# вернуть лиш один ответ если задано одно число и много ответов списком если
# введённых значений будет несколько! И добавьте его к функции rope_product
# не меняя решения из предыдущего решения!
# rope_product(8) -> 18
# rope_product(7,11,23,45,32) -> [12, 54, 4374, 14348907, 118098]
# здесь можно пользоваться циклами

def handle_multiples(func):
    # Здесь мы определяем внутреннюю функцию с именем wrapper, которая может принимать произвольное количество аргументов
    def wrapper(*args):
        if len(args) == 1:
            # Если был передан только один аргумент, то вызывается функция func с этим аргументом
            return func(*args)
        else:
            # Иначе, если было передано несколько аргументов, мы обрабатываем их все и возвращаем список результатов
            return [func(arg) for arg in args]
    # Наконец, функция handle_multiples возвращает внутреннюю функцию wrapper в качестве результата
    return wrapper
    # Декторатор верный


@handle_multiples
def rope_product(n):
    if isinstance(n, int):
        if n <= 4:
            return n
        num_threes = n // 3
        remainder = n % 3
        if remainder == 1:
            num_threes -= 1
            remainder = 4
        return int(math.pow(3, num_threes) * remainder)
    else:
        raise ValueError("Ввод должен быть целым числом")
        # Решение ок


# Создайте функцию rope_product, которая берёт позитивный цельный номер,
# который представляет собой длину верёвки. Длина этой
# верёвки может быть разделена на любое количество более
# малых цельных чисел. Верните максимальный продукт умножения
# малых цельных чисел. Решение не должно пользоваться циклами!


# rope_product(1) -> 1
# rope_product(4) -> 4
# rope_product(5) -> 6
# rope_product(6) -> 9
# rope_product(7) -> 12
# rope_product(11) -> 54


def rope_product(n):
    # Проверим, n меньше или равно 4
    if n <= 4:
        # Если условие верно, функция возвращает значение n
        return n
    # Эта строка вычисляет количество троек, которые можно использовать полностью в числе n
    num_threes = n // 3
    # Здесь вычисляется остаток от деления n на 3
    remainder = n % 3
    # Это условие проверяет, если остаток от деления равен 1
    if remainder == 1:
        # Если остаток равен 1, уменьшаем количество троек на 1
        num_threes -= 1
        # Устанавливаем значение остатка в 4, так как мы заменили одну тройку на четверку
        remainder = 4
    # Возвращаем результат умножения трех в степени num_threes на остаток remainder
    return int(math.pow(3, num_threes) * remainder)
    # Решение тоже ок, но должно быть одно решение этой задачи и для задачи с веревкой и для задачи с декотором. Тесты с декоторатом не проходит
